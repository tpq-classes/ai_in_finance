{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src='http://hilpisch.com/taim_logo.png' width=\"350px\" align=\"right\">"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# AI-First Finance\n",
    "\n",
    "**Deep Learning Improvements**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Dr Yves J Hilpisch | The AI Machine\n",
    "\n",
    "http://aimachine.io | http://twitter.com/dyjh"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Imports"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "execution_count": null,
   "outputs": [],
   "source": [
    "!git clone https://github.com/tpq-classes/ai_in_finance.git\n",
    "import sys\n",
    "sys.path.append('ai_in_finance')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from pylab import plt\n",
    "plt.style.use('seaborn-v0_8')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Universal Approximation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### With Keras"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = np.linspace(0, 5 * np.pi, 100)\n",
    "y = np.cos(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(x, y, 'ro');"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "from keras.layers import Dense\n",
    "from keras.models import Sequential"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = Sequential()\n",
    "model.add(Dense(8 * 48, input_dim=1, activation='relu'))\n",
    "model.add(Dense(4 * 24, activation='relu'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# estimation\n",
    "model.add(Dense(1, activation='linear'))\n",
    "model.compile(loss='mse', optimizer='adam', metrics=['mse', 'accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(x, y, epochs=2000, verbose=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "scores = model.evaluate(x, y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('mse: %.5f' % (scores[1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# estimation\n",
    "pred = model.predict(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(x, y, 'ro', label='original data')\n",
    "plt.plot(x, pred, label='prediction')\n",
    "plt.legend();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Activation Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def activation(x, act='linear', deriv=False):\n",
    "    if act == 'sigmoid':\n",
    "        if deriv:\n",
    "            out = activation(x, 'sigmoid', False)\n",
    "            return out * (1 - out)\n",
    "        return 1 / (1 + np.exp(-x))\n",
    "    elif act == 'relu':\n",
    "        if deriv:\n",
    "            return np.where(x > 0, 1, 0)\n",
    "        return np.maximum(x, 0)\n",
    "    elif act == 'softplus':\n",
    "        if deriv:\n",
    "            return activation(x, act='sigmoid')\n",
    "        return np.log(1 + np.exp(x))\n",
    "    elif act == 'linear':\n",
    "        if deriv:\n",
    "            return 1\n",
    "        return x\n",
    "    else:\n",
    "        raise ValueError('Activation function not known.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = np.linspace(-1, 1, 20)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "activation(x, 'sigmoid')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "activation(x, 'sigmoid', True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Learning &mdash; Simple Neural Network"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Features & Labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "features = 5\n",
    "samples = 5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.random.seed(10)\n",
    "l0 = np.random.random((samples, features))\n",
    "l0  # input layer (features)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.linalg.matrix_rank(l0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = np.random.random((samples, 1))   # labels\n",
    "y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "reg = np.linalg.lstsq(l0, y, rcond=-1)[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "reg"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.allclose(np.dot(l0, reg), y)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def snn_function(l0, y, act='linear', a=0.01, steps=100, verbose=False):\n",
    "    samples, features = l0.shape\n",
    "    w = np.random.random((features, 1))\n",
    "    for s in range(1, steps + 1):\n",
    "        l2 = activation(np.dot(l0, w))\n",
    "        e = l2 - y\n",
    "        d = e * activation(l2, act, True)\n",
    "        u = a * np.dot(l0.T, d)\n",
    "        w -= u\n",
    "        mse = (e ** 2).mean()\n",
    "        if s % 20 == 0 and verbose:\n",
    "            print(f'step={s:3d} | mse={mse:.5f}')\n",
    "    return w, mse"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "w, mse = snn_function(l0, y, a=0.05, steps=50000, act='linear')\n",
    "mse"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "res = pd.DataFrame({'y': y.flatten(),\n",
    "                    'pred': np.dot(l0, w).flatten()},\n",
    "                   index=range(len(y)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "res.plot(kind='bar', figsize=(10, 6));"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### First Class"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class snn:\n",
    "    def __init__(self, act='linear', a=0.01, steps=100, verbose=False):\n",
    "        self.act= act\n",
    "        self.a = a\n",
    "        self.steps = steps\n",
    "        self.verbose = verbose\n",
    "    def fit(self, l0, y, steps=None):\n",
    "        if steps is None:\n",
    "            steps = self.steps\n",
    "        samples, features = l0.shape\n",
    "        w = np.random.random((features, 1))\n",
    "        for s in range(1, steps + 1):\n",
    "            l2 = activation(np.dot(l0, w), self.act)\n",
    "            e = l2 - y\n",
    "            d = e * activation(l2, self.act, True)\n",
    "            u = self.a * np.dot(l0.T, d)\n",
    "            w -= u\n",
    "            mse = (e ** 2).mean()\n",
    "            if s % 20 == 0 and self.verbose:\n",
    "                print(f'step={s:3d} | mse={mse:.5f}')\n",
    "        self.w = w\n",
    "        self.mse = mse\n",
    "        print(f'mse={mse:.5f}')\n",
    "    def predict(self, l0):\n",
    "        return activation(np.dot(l0, self.w), self.act)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = snn(a=0.0025, act='softplus', steps=200000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.fit(l0, y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.predict(l0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.predict(l0) - y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "res = pd.DataFrame({'y': y.flatten(),\n",
    "                    'pred': model.predict(l0).flatten()},\n",
    "                   index=range(len(y)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "res.plot(kind='bar', figsize=(10, 6));"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "features = 5\n",
    "samples = 10"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.random.seed(3)\n",
    "l0 = np.random.randint(0, 2, (samples, features))\n",
    "l0  # input layer (features)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.linalg.matrix_rank(l0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = np.random.randint(0, 2, (samples, 1))   # labels\n",
    "y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = snn(a=0.01, act='sigmoid')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.fit(l0, y, 3000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.predict(l0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.predict(l0).round() == y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Refactored Class"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class snn:\n",
    "    def __init__(self, act='linear', a=0.01, steps=100,\n",
    "                 verbose=False, psteps=200):\n",
    "        self.act= act\n",
    "        self.a = a\n",
    "        self.steps = steps\n",
    "        self.verbose = verbose\n",
    "        self.psteps = psteps\n",
    "    def forward(self):\n",
    "        self.l2 = activation(np.dot(self.l0, self.w), self.act)\n",
    "    def backward(self):\n",
    "        self.e = self.l2 - self.y  # error ...\n",
    "        d = self.e * activation(self.l2, self.act, True)  # ... is propagated ..\n",
    "        u = self.a * np.dot(self.l0.T, d)  # ... backwards\n",
    "        # u = a * np.dot(l0.T, e * activation(l2, self.act, True))\n",
    "        self.w -= u\n",
    "    def metrics(self, s):\n",
    "        mse = (self.e ** 2).mean()\n",
    "        acc = float(sum(self.l2.round() == self.y)[0] / len(self.y))\n",
    "        self.res = pd.concat((self.res,\n",
    "            pd.DataFrame({'mse': mse, 'acc': acc}, index=[s,]))\n",
    "        )\n",
    "        if s % self.psteps == 0 and self.verbose:\n",
    "                print(f'step={s:5d} | mse={mse:.5f}')\n",
    "                print(f'           | acc={acc:.5f}')\n",
    "    def fit(self, l0, y, steps=None):\n",
    "        self.l0 = l0\n",
    "        self.y = y\n",
    "        if steps is None:\n",
    "            steps = self.steps\n",
    "        self.res = pd.DataFrame()\n",
    "        samples, features = l0.shape\n",
    "        self.w = np.random.random((features, 1))\n",
    "        for s in range(1, steps + 1):\n",
    "            self.forward()\n",
    "            self.backward()\n",
    "            self.metrics(s)\n",
    "    def predict(self, X):\n",
    "        return activation(np.dot(X, self.w), self.act)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = snn(a=0.05, act='sigmoid')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.fit(l0, y, 1000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.res.plot(figsize=(10, 6), secondary_y='mse');"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Learning &mdash; One Hidden Layer"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Shallow neural network = ONE hidden layer = not DEEP neural network."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class onn:\n",
    "    def __init__(self, units=12, act='linear', a=0.01, steps=100,\n",
    "                 verbose=False, psteps=200):\n",
    "        self.units = units\n",
    "        self.act= act\n",
    "        self.a = a\n",
    "        self.steps = steps\n",
    "        self.verbose = verbose\n",
    "        self.psteps = psteps\n",
    "    def initialize(self):\n",
    "        samples, features = self.l0.shape\n",
    "        self.w0 = np.random.random((features, self.units))\n",
    "        self.w1 = np.random.random((self.units, 1))\n",
    "    def forward(self):\n",
    "        self.l1 = activation(np.dot(self.l0, self.w0), self.act)\n",
    "        self.l2 = activation(np.dot(self.l1, self.w1), self.act)\n",
    "    def backward(self):\n",
    "        self.e = self.l2 - self.y\n",
    "        d2 = self.e * activation(self.l2, self.act, True)\n",
    "        u2 = self.a * np.dot(self.l1.T, d2)\n",
    "        self.w1 -= u2\n",
    "        e1 = np.dot(d2, self.w1.T)\n",
    "        d1 = e1 * activation(self.l1, self.act, True)\n",
    "        u1 = self.a * np.dot(self.l0.T, d1)\n",
    "        self.w0 -= u1\n",
    "    def metrics(self, s):\n",
    "        mse = (self.e ** 2).mean()\n",
    "        acc = float(sum(self.l2.round() == self.y)[0] / len(self.y))\n",
    "        self.res = pd.concat((self.res,\n",
    "            pd.DataFrame({'mse': mse, 'acc': acc}, index=[s,]))\n",
    "        )\n",
    "        if s % self.psteps == 0 and self.verbose:\n",
    "                print(f'step={s:5d} | mse={mse:.5f}')\n",
    "                print(f'           | acc={acc:.5f}')\n",
    "    def fit(self, l0, y, steps=None):\n",
    "        self.l0 = l0\n",
    "        self.y = y\n",
    "        if steps is None:\n",
    "            steps = self.steps\n",
    "        self.res = pd.DataFrame()\n",
    "        self.initialize()\n",
    "        self.forward()\n",
    "        for s in range(1, steps + 1):\n",
    "            self.backward()\n",
    "            self.forward()\n",
    "            self.metrics(s)\n",
    "    def predict(self, X):\n",
    "        l1 = activation(np.dot(X, self.w0), self.act)\n",
    "        l2 = activation(np.dot(l1, self.w1), self.act)\n",
    "        return l2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "features = 5\n",
    "samples = 10"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0 = np.random.random((samples, features))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.linalg.matrix_rank(l0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = np.random.random((samples, 1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = onn(a=0.001, act='softplus')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(l0, y, 5000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.res.mse.min()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.res['mse'].iloc[40:].plot(figsize=(10, 6));"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "res = pd.DataFrame({'y': y.flatten(),\n",
    "                    'pred': model.predict(l0).flatten()},\n",
    "                   index=range(len(y)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "res.plot(kind='bar', figsize=(10, 6));"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = onn(a=0.025, act='sigmoid', steps=10000, verbose=True, psteps=2000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0.round()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y.round()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.fit(l0.round(), y.round())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ax = model.res.plot(figsize=(10, 6), secondary_y='mse')\n",
    "ax.get_legend().set_bbox_to_anchor((0.1, 0.5));"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Improved Optimizer"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Class"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class oonn:\n",
    "    def __init__(self, units=12, act='linear', a=0.01, momentum=0.1,\n",
    "                 steps=100, verbose=False, psteps=200, seed=None):\n",
    "        self.units = units\n",
    "        self.act= act\n",
    "        self.a = a\n",
    "        self.momentum = momentum\n",
    "        self.steps = steps\n",
    "        self.verbose = verbose\n",
    "        self.psteps = psteps\n",
    "        self.seed = seed\n",
    "    def initialize(self):\n",
    "        if self.seed is not None:\n",
    "            np.random.seed(self.seed)\n",
    "        samples, features = self.l0.shape\n",
    "        self.w0 = np.random.random((features, self.units))\n",
    "        self.w1 = np.random.random((self.units, 1))\n",
    "        self.v1 = 0.\n",
    "        self.v2 = 0.\n",
    "        self.max_acc = 0.\n",
    "        self.min_mse = 1000.\n",
    "        self.best_w0 = self.w0.copy()\n",
    "        self.best_w1 = self.w1.copy()\n",
    "    def forward(self):\n",
    "        self.l1 = activation(np.dot(self.l0, self.w0), self.act)\n",
    "        self.l2 = activation(np.dot(self.l1, self.w1), self.act)\n",
    "        self.e = self.l2 - self.y\n",
    "    def backward(self):\n",
    "        self.e = self.l2 - self.y\n",
    "        d2 = self.e * activation(self.l2, self.act, True)\n",
    "        v2 = self.v2 * self.momentum + self.a * np.dot(self.l1.T, d2)\n",
    "        self.w1 = self.w1 + self.momentum * v2 - self.a * np.dot(self.l1.T, d2)\n",
    "        self.v2 = v2\n",
    "        e1 = np.dot(d2, self.w1.T)\n",
    "        d1 = e1 * activation(self.l1, self.act, True)\n",
    "        v1 = self.v1 * self.momentum + self.a * np.dot(self.l0.T, d1)\n",
    "        self.w0 = self.w0 + self.momentum * v1 - self.a * np.dot(self.l0.T, d1)\n",
    "        self.v1 = v1\n",
    "    def metrics(self, s):\n",
    "        mse = (self.e ** 2).mean()\n",
    "        acc = float(sum(self.l2.round() == self.y)[0] / len(self.y))\n",
    "        if acc > self.max_acc and self.target == 'acc':\n",
    "            self.max_acc = acc\n",
    "            self.best_w0 = self.w0.copy()\n",
    "            self.best_w1 = self.w1.copy()\n",
    "        elif mse < self.min_mse and self.target == 'mse':\n",
    "            self.min_mse = mse\n",
    "            self.best_w0 = self.w0.copy()\n",
    "            self.best_w1 = self.w1.copy()\n",
    "        opt = float(sum(self.predict(self.l0).round()[0] == self.y)[0] / len(self.y))\n",
    "        self.res = pd.concat((self.res,\n",
    "            pd.DataFrame({'mse': mse, 'acc': acc, 'opt': opt}, index=[s,]))\n",
    "        )\n",
    "        if s % self.psteps == 0 and self.verbose:\n",
    "                print(f'step={s:5d} | mse={mse:.5f}')\n",
    "                print(f'           | acc={acc:.5f}')\n",
    "                print(f'           | opt={opt:.5f}')\n",
    "    def fit(self, l0, y, target='acc', steps=None):\n",
    "        self.target = target\n",
    "        self.l0 = l0\n",
    "        self.y = y\n",
    "        if steps is None:\n",
    "            steps = self.steps\n",
    "        self.res = pd.DataFrame()\n",
    "        self.initialize()\n",
    "        self.forward()\n",
    "        for s in range(1, steps + 1):\n",
    "            self.backward()\n",
    "            self.forward()\n",
    "            self.metrics(s)\n",
    "    def predict(self, X):\n",
    "        l1 = activation(np.dot(X, self.best_w0), self.act)\n",
    "        l2 = activation(np.dot(l1, self.best_w1), self.act)\n",
    "        return l2\n",
    "    def plot_metrics(self, ms=5, lw=2.0):\n",
    "        model.res.plot(figsize=(10, 6), style=['o', 'o', '--'], ms=ms, lw=lw)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "features = 5\n",
    "samples = 15"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.random.seed(10)\n",
    "l0 = np.random.random((samples, features))\n",
    "l0[:5]  # input layer (features)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = np.random.random((samples, 1))   # labels\n",
    "y[:5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = oonn(units=64, a=0.0005, act='softplus', steps=1000,\n",
    "            verbose=True, psteps=200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(l0, y, target='mse')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.min_mse"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics(7, 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "res = pd.DataFrame({'y': y.flatten(),\n",
    "                    'pred': model.predict(l0).flatten()},\n",
    "                   index=range(len(y)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "res.plot(kind='bar', figsize=(10, 6));"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Classification"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0 = l0.round()\n",
    "l0[:5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = y.round()\n",
    "y[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Simple Optimizer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = onn(a=0.05, act='sigmoid',\n",
    "           verbose=True, psteps=1000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.fit(l0, y, 4000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.res.plot(figsize=(10, 6));"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Improved Optimizer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = oonn(a=0.05, act='sigmoid',\n",
    "             verbose=True, psteps=1000, seed=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "model.fit(l0, y, target='acc', steps=4000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics(1.5, 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Financial Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "url = 'http://hilpisch.com/tr_eikon_eod_data.csv'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "raw = pd.read_csv(url, index_col=0, parse_dates=True).dropna()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "raw.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sym = 'AAPL.O'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "lags = 5\n",
    "cols = []\n",
    "data = pd.DataFrame(raw[sym])\n",
    "data['r'] = np.log(data / data.shift(1))\n",
    "data['d'] = np.where(data['r'] > 0, 1, 0)\n",
    "for lag in range(1, lags+1):\n",
    "    col = f'lag_{lag}'\n",
    "    data[col] = data['d'].shift(lag)\n",
    "    cols.append(col)\n",
    "data.dropna(inplace=True)\n",
    "data[cols] = data[cols].astype(int)\n",
    "data = data.iloc[-500:]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "data.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fitting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = oonn(units=16 * 4, a=0.0001, momentum=0.05, act='sigmoid',\n",
    "             verbose=True, psteps=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = data['d'].values.reshape(-1, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(data[cols].values, y, target='acc', steps=500)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.max_acc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics(3, 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Batching"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Class"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class bonn(oonn):\n",
    "    def forward(self):\n",
    "        self.l1 = activation(np.dot(self.l0, self.w0), self.act)\n",
    "        self.l2 = activation(np.dot(self.l1, self.w1), self.act)\n",
    "        self.l1_ = activation(np.dot(self.l0_, self.w0), self.act)\n",
    "        self.l2_ = activation(np.dot(self.l1_, self.w1), self.act)\n",
    "    def metrics(self, s):\n",
    "        self.e = self.l2_ - self.y_\n",
    "        mse = (self.e ** 2).mean()\n",
    "        acc = float(sum(self.l2_.round() == self.y_)[0] / len(self.y_))\n",
    "        if acc > self.max_acc and self.target == 'acc':\n",
    "            self.max_acc = acc\n",
    "            self.best_w0 = self.w0.copy()\n",
    "            self.best_w1 = self.w1.copy()\n",
    "        elif mse < self.min_mse and self.target == 'mse':\n",
    "            self.min_mse = mse\n",
    "            self.best_w0 = self.w0.copy()\n",
    "            self.best_w1 = self.w1.copy()\n",
    "        opt = float(sum(self.predict(self.l0_).round() == self.y_)[0] / len(self.y_))\n",
    "        self.res = pd.concat((self.res,\n",
    "            pd.DataFrame({'mse': mse, 'acc': acc, 'opt': opt}, index=[s,]))\n",
    "        )\n",
    "        if s % self.psteps == 0 and self.verbose:\n",
    "                print(f'step={s:5d} | mse={mse:.5f}')\n",
    "                print(f'           | acc={acc:.5f}')\n",
    "                print(f'           | opt={opt:.5f}')\n",
    "    def fit(self, l0, y, target='acc', batch_size=32, steps=None):\n",
    "        self.target = target\n",
    "        self.l0_ = l0\n",
    "        self.y_ = y\n",
    "        if steps is None:\n",
    "            steps = self.steps\n",
    "        self.res = pd.DataFrame()\n",
    "        n = int(len(y) / batch_size)\n",
    "        i = 0\n",
    "        self.min_mse = 0\n",
    "        for b in range(n):\n",
    "            self.l0 = self.l0_[b:b + batch_size]\n",
    "            self.y = self.y_[b:b + batch_size]\n",
    "            if b == 0:\n",
    "                self.initialize()\n",
    "            self.forward()\n",
    "            for s in range(steps):\n",
    "                i += 1\n",
    "                self.backward()\n",
    "                self.forward()\n",
    "                if i % 5 == 0:\n",
    "                    self.metrics(i)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fitting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = bonn(units=256, a=0.01, momentum=0.1,\n",
    "             act='sigmoid', verbose=True, psteps=500, seed=10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = data['d'].values.reshape(-1, 1)\n",
    "len(y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time\n",
    "model.fit(data[cols].values, y, target='acc',\n",
    "                batch_size=32, steps=200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.max_acc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Adjusting Features"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Bucketing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### The Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "lags = 5\n",
    "data = pd.DataFrame(raw[sym])\n",
    "data['r'] = np.log(data / data.shift(1))\n",
    "data['d'] = np.where(data['r'] > 0, 1, 0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cols = []\n",
    "for lag in range(1, lags+1):\n",
    "    col = f'lag_{lag}'\n",
    "    data[col] = data['r'].shift(lag)\n",
    "    cols.append(col)\n",
    "data.dropna(inplace=True)\n",
    "data = data.iloc[-500:]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "data.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mu = data['r'].mean()\n",
    "std = data['r'].std()\n",
    "bins = [mu - std / 2, mu, mu + std / 2]\n",
    "# bins = [mu - std, mu - std / 2, mu, mu + std / 2, mu + std]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0 = np.digitize(data[cols].values, bins)\n",
    "y = data['d'].values.reshape(-1, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Fitting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = oonn(units=64, a=0.001, momentum=0.1,\n",
    "             act='sigmoid', verbose=True, psteps=500, seed=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(l0, y, target='acc', steps=2000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.max_acc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Normalization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = oonn(units=128 * 8, a=0.005, momentum=0.1,\n",
    "             act='sigmoid', verbose=True, psteps=500, seed=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def normalize(x):\n",
    "    return (x - x.mean()) / x.std()\n",
    "def unit(x):\n",
    "    return (x - x.min()) / (x.max() - x.min())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# l0 = data[cols].values\n",
    "# l0 = normalize(data[cols].values)\n",
    "l0 = unit(data[cols].values)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0.min(), l0.max()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0[:5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y[:5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(l0, y, target='acc', steps=1000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.max_acc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Validation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class vonn(oonn):\n",
    "    def metrics(self, s):\n",
    "        mse = (self.e ** 2).mean()\n",
    "        acc = float(sum(self.l2.round() == self.y)[0] / len(self.y))\n",
    "        if acc > self.max_acc and self.target == 'acc':\n",
    "            self.max_acc = acc\n",
    "            self.best_w0 = self.w0.copy()\n",
    "            self.best_w1 = self.w1.copy()\n",
    "        elif mse < self.min_mse and self.target == 'mse':\n",
    "            self.min_mse = mse\n",
    "            self.best_w0 = self.w0.copy()\n",
    "            self.best_w1 = self.w1.copy()\n",
    "        opt = float(sum(self.predict(self.l0).round() == self.y)[0] / len(self.y))\n",
    "        val = float(sum(self.predict(self.vl0).round() == self.vy)[0] / len(self.vy))\n",
    "        self.res = pd.concat((self.res,\n",
    "            pd.DataFrame({'mse': mse, 'acc': acc, 'opt': opt, 'val': val}, index=[s,]))\n",
    "        )\n",
    "        if s % self.psteps == 0 and self.verbose:\n",
    "                print(f'step={s:5d} | mse={mse:.5f}')\n",
    "                print(f'           | acc={acc:.5f}')\n",
    "                print(f'           | opt={opt:.5f}')\n",
    "                print(f'           | val={val:.5f}')\n",
    "    def fit(self, l0, y, val=0.2, target='acc', steps=None):\n",
    "        split = int(len(y) * (1 - val))\n",
    "        self.l0 = l0[:split]\n",
    "        self.y = y[:split]\n",
    "        self.vl0 = l0[split:]\n",
    "        self.vy = y[split:]\n",
    "        self.target = target\n",
    "        if steps is None:\n",
    "            steps = self.steps\n",
    "        self.res = pd.DataFrame()\n",
    "        self.initialize()\n",
    "        self.min_mse = 100.\n",
    "        self.forward()\n",
    "        for s in range(1, steps + 1):\n",
    "            self.backward()\n",
    "            self.forward()\n",
    "            self.metrics(s)\n",
    "    def plot_metrics(self, ms=5, lw=2.0):\n",
    "        model.res.plot(figsize=(10, 6), style=['o', 'o', '--', 'o'], ms=ms, lw=lw)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = vonn(units=64, a=0.001, momentum=0.1,\n",
    "             act='sigmoid', verbose=True, psteps=200, seed=10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0 = normalize(data[cols].values)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(l0, y, target='acc', val=0.20, steps=800)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.max_acc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.res.tail()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Vectorized Backtesting"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "lags = 10\n",
    "sym = 'GLD'\n",
    "data = pd.DataFrame(raw[sym])\n",
    "data['r'] = np.log(data / data.shift(1))\n",
    "data['d'] = np.where(data['r'] > 0, 1, 0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cols = []\n",
    "for lag in range(1, lags+1):\n",
    "    col = f'lag_{lag}'\n",
    "    data[col] = data['r'].shift(lag)\n",
    "    cols.append(col)\n",
    "data.dropna(inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train = data.iloc[-1500:-500]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test = data.iloc[-500:].copy()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fitting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = vonn(units=128, a=0.001, momentum=0.1,\n",
    "             act='sigmoid', verbose=True, psteps=200, seed=10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0 = normalize(train[cols].values)\n",
    "y = train['d'].values.reshape(-1, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(l0, y, target='acc', steps=1000, val=0.20)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.max_acc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.res.tail()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Backtesting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l0_ = normalize(test[cols].values)\n",
    "y_ = test['d'].values.reshape(-1, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test['pred'] = model.predict(l0_).round()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sum(test['pred'] == y_.flatten()) / len(y_)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test['p'] = np.where(test['pred'] == 1, 1, -1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test['p'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "sum(test['p'].diff() != 0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test['s'] = test['p'] * test['r']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test[['r', 's']].sum().apply(np.exp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test[['r', 's']].cumsum().apply(np.exp).plot(figsize=(10, 6));"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Universal Approximation with OONN"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = np.linspace(0, 5 * np.pi, 100)\n",
    "y = np.cos(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "i = 30\n",
    "N = 20"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# x_ = normalize(np.random.random((N, N)))\n",
    "x_ = unit(x[i:i+N]).reshape(-1, 1)\n",
    "y_ = unit(y[i:i+N]).reshape(-1, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x_.shape, y_.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(x_, y_, 'ro');"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = oonn(units=512 * 4, a=0.01, momentum=0.1, steps=10000,\n",
    "             act='sigmoid', verbose=True, psteps=2000, seed=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%time model.fit(x_, y_, target='mse')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.plot_metrics()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.min_mse"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pred = model.predict(x_)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(y_.flatten(), 'ro', label='original data')\n",
    "plt.plot(pred, label='prediction')\n",
    "plt.legend();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src='http://hilpisch.com/taim_logo.png' width=\"350px\" align=\"right\">"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "name": "python3",
   "display_name": "Python 3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.16"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}